{
  "setName": "React",
  "data": [
    {
      "question": "What is React?",
      "answer": "React is a JavaScript library for building UI using reusable components and efficient rendering via the Virtual DOM."
    },
    {
      "question": "What are components?",
      "answer": "Components are reusable UI blocks. Functional components use functions and hooks; class components use classes and lifecycle methods."
    },
    {
      "question": "What is JSX?",
      "answer": "JSX lets you write HTML-like syntax inside JavaScript; React compiles it into plain JavaScript."
    },
    {
      "question": "What is the DOM?",
      "answer": "The DOM is the browser’s tree-like representation of UI elements."
    },
    {
      "question": "What is the Virtual DOM?",
      "answer": "A lightweight JavaScript representation of the DOM that React uses to update UI efficiently."
    },
    {
      "question": "What is reconciliation?",
      "answer": "React’s diffing algorithm that updates only the parts of the DOM that changed."
    },
    {
      "question": "What are React Fragments?",
      "answer": "Fragments let you wrap multiple elements without adding extra DOM nodes."
    },
    {
      "question": "What are props?",
      "answer": "Props are read-only inputs passed from a parent component to a child."
    },
    {
      "question": "What is state?",
      "answer": "State is internal component data that triggers re-rendering when changed."
    },
    {
      "question": "Difference between state and props?",
      "answer": "Props are external and immutable; state is internal and mutable."
    },
    {
      "question": "What is prop drilling?",
      "answer": "Passing props through multiple layers unnecessarily."
    },
    {
      "question": "How to avoid prop drilling?",
      "answer": "Use the Context API, Redux, Zustand, or other global state solutions."
    },
    {
      "question": "What are Pure Components?",
      "answer": "Components that prevent re-renders by shallowly comparing props and state."
    },
    {
      "question": "What are refs?",
      "answer": "Refs allow access to DOM elements or store mutable values without re-rendering."
    },
    {
      "question": "What is forwardRef?",
      "answer": "A technique to pass a ref from a parent component to a child component."
    },
    {
      "question": "What are Error Boundaries?",
      "answer": "Special components that catch JavaScript errors in UI and display fallback UI."
    },
    {
      "question": "What are Higher-Order Components (HOCs)?",
      "answer": "Functions that take a component and return an enhanced component."
    },
    {
      "question": "What are controlled components?",
      "answer": "Form inputs whose values are controlled by React state."
    },
    {
      "question": "What are uncontrolled components?",
      "answer": "Inputs where form data is handled by the DOM using refs."
    },
    {
      "question": "What is useState?",
      "answer": "A React hook used to manage state inside functional components."
    },
    {
      "question": "What is useEffect?",
      "answer": "A hook for side effects such as fetching data or subscribing to events."
    },
    {
      "question": "What is the dependency array in useEffect?",
      "answer": "It controls when the effect runs; empty array means it runs once."
    },
    {
      "question": "Difference between useEffect and useLayoutEffect?",
      "answer": "useLayoutEffect runs before DOM paint; useEffect runs after paint."
    },
    {
      "question": "What is useMemo?",
      "answer": "A hook that memoizes expensive computations to improve performance."
    },
    {
      "question": "What is useCallback?",
      "answer": "A hook that memoizes a function to avoid unnecessary re-renders."
    },
    {
      "question": "Difference between useMemo and useCallback?",
      "answer": "useMemo returns a memoized value; useCallback returns a memoized function."
    },
    {
      "question": "What is React.memo?",
      "answer": "A wrapper that prevents re-renders when props do not change."
    },
    {
      "question": "What is lazy loading?",
      "answer": "Loading components only when needed using React.lazy."
    },
    {
      "question": "What is Suspense?",
      "answer": "A component that shows a fallback UI while lazy-loaded components load."
    },
    {
      "question": "What are custom hooks?",
      "answer": "Reusable JavaScript functions that encapsulate shared component logic."
    },
    {
      "question": "What is useReducer?",
      "answer": "A hook for managing complex state using reducer logic."
    },
    {
      "question": "What are Portals?",
      "answer": "A way to render components into a DOM node outside the root element."
    },
    {
      "question": "What is Context API?",
      "answer": "A way to manage and provide global data without prop drilling."
    },
    {
      "question": "Examples of Context usage?",
      "answer": "Theme, authentication, language, app-wide settings."
    },
    {
      "question": "Why pass a callback inside setState?",
      "answer": "To safely update state based on previous state values."
    },
    {
      "question": "How to send data from child to parent?",
      "answer": "Parent passes a callback; child calls it with data."
    },
    {
      "question": "How to send data to parent using refs?",
      "answer": "Use forwardRef along with useImperativeHandle."
    },
    {
      "question": "How to consume REST APIs in React?",
      "answer": "Use fetch or axios inside useEffect to load data."
    },
    {
      "question": "How to optimize React performance?",
      "answer": "Use memoization, React.memo, code-splitting, virtualization, and avoiding unnecessary renders."
    },
    {
      "question": "CSR vs SSR?",
      "answer": "CSR renders in the browser; SSR renders HTML on the server (better for SEO)."
    },
    {
      "question": "What are synthetic events?",
      "answer": "React's wrapper around browser events to make behavior consistent across browsers."
    },
    {
      "question": "package.json vs package-lock.json?",
      "answer": "package.json lists dependencies; package-lock.json locks exact installed versions."
    },
    {
      "question": "What is StrictMode?",
      "answer": "A development tool that highlights potential problems."
    },
    {
      "question": "Why are keys used in lists?",
      "answer": "To help React identify which items changed, added, or were removed."
    },
    {
      "question": "What happens if a key is missing?",
      "answer": "React may re-render inefficiently and cause UI inconsistencies."
    },
    {
      "question": "createElement vs cloneElement?",
      "answer": "createElement creates new elements; cloneElement clones and modifies existing ones."
    },
    {
      "question": "What are render props?",
      "answer": "A technique where a component receives a function that returns UI."
    },
    {
      "question": "What are protected routes?",
      "answer": "Routes that require authentication to access."
    },
    {
      "question": "Does React Router support context menus?",
      "answer": "Yes — custom context menu events can be attached to route components."
    },
    {
      "question": "What is React Fiber?",
      "answer": "The new core architecture for React enabling incremental and interruptible rendering."
    },
    {
      "question": "What is Concurrent Rendering?",
      "answer": "A rendering approach where React can pause, resume, or cancel renders for better performance."
    },
    {
      "question": "What is the reconciliation algorithm?",
      "answer": "React’s diffing algorithm comparing old and new virtual DOM trees."
    }
  ]
}
